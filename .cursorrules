# Next.js and Frontend
*.ts linguist-language=TypeScript
*.tsx linguist-language=TypeScript
*.js linguist-language=JavaScript
*.jsx linguist-language=JavaScript
*.css linguist-language=CSS

# Soroban Smart Contracts (Stellar)
*.rs linguist-language=Rust
Cargo.toml linguist-language=TOML
soroban-config.json linguist-language=JSON

# Build and Dependencies
target/ linguist-generated=true
target/ -diff
**/target/ linguist-generated=true
**/target/ -diff
.next/ linguist-generated=true
.next/ -diff
dist/ linguist-generated=true
dist/ -diff

# Soroban Build Artifacts
**/*.wasm linguist-generated=true
.soroban/ linguist-generated=true
.soroban/ -diff

# Documentation
*.md linguist-documentation
docs/ linguist-documentation
README.md linguist-documentation

# Test Files
*_test.rs linguist-language=Rust
*.test.ts linguist-language=TypeScript
*.test.tsx linguist-language=TypeScript
tests/ linguist-language=Rust
__tests__/ linguist-language=TypeScript

# IDE and Editor Files
.vscode/ linguist-vendored
.idea/ linguist-vendored
*.json linguist-language=JSON
.env.* linguist-language=Text

# Package Management
node_modules/ linguist-vendored
node_modules/ -diff
yarn.lock linguist-generated=true
package-lock.json linguist-generated=true

# Ignore binary files
*.wasm binary
*.jpg binary
*.png binary
*.gif binary
*.ico binary
*.pdf binary

# Configuration Files
*.config.js linguist-language=JavaScript
*.config.ts linguist-language=TypeScript
tailwind.config.js linguist-language=JavaScript
next.config.js linguist-language=JavaScript
postcss.config.js linguist-language=JavaScript

# Database
*.sql linguist-language=SQL
prisma/ linguist-language=Prisma
drizzle/ linguist-language=TypeScript

# Security
.env.example linguist-language=Text

You are an expert developer in TypeScript, Node.js, Next.js 15 App Router, React, Supabase, GraphQL, Genql, DrizzleORM, Tailwind CSS, Radix UI, and Shadcn UI.

---

## Coding Philosophy
Our coding philosophy revolves around writing **semantic, idiomatic, functional, and declarative code**. Follow these key principles:

- **Modern JavaScript & TypeScript:**  
  Leverage the latest features for expressive, maintainable code with an emphasis on TypeScript's type safety.
- **Declarative React:**  
  Describe UI structure and state, avoiding imperative code.
- **Readable Naming:**  
  Use self-explanatory names for variables, functions, and components.
- **Single Responsibility Principle:**  
  Keep components focused and reusable.
- **Favor Composition Over Inheritance:**  
  Build components and functions that promote modularity and reusability.
- **File Organization:**  
  Structure code logically, keeping readability and scalability in mind.
- **Utility-First Styling:**  
  Use TailwindCSS for rapid and consistent UI development.

---

## General Conventions
- **Project Structure:**  
  - Organize components in a well-structured manner.
  - Separate concerns with clear folder structures.
  - Follow monorepo best practices (`apps/`, `packages/`,`services/`, `config/`).

- **Filenames:**  
  - Use lowercase with dash separators (e.g., `auth-wizard.tsx`).
  - File extensions should indicate file types (e.g., `.config.ts`, `.test.ts`, `.hook.tsx`).

- **Exporting:**  
  - Prefer named exports over default exports.

---

## JavaScript/TypeScript Best Practices
- **Naming Variables:**  
  - Use meaningful names that reflect purpose.
  - Prefix booleans with auxiliary verbs (e.g., `isLoading`, `hasPermission`).

- **Functional Programming:**  
  - Prefer `function` declarations for components.
  - Use the RORO (Receive an Object, Return an Object) pattern.

- **TypeScript Usage:**  
  - Use `interface` for objects and class definitions.
  - Use `type` for unions, tuples, and aliases.
  - Avoid `any`; prefer explicit types and inference when possible.
  - Use `as` for type assertions when necessary.
  - Explicitly annotate function parameters and return types.

- **JavaScript Performance (LOW-MEDIUM):**
  - Group CSS changes via classes or `cssText` instead of individual style properties.
  - Build Map/Set for repeated lookups (O(1) vs O(n)).
  - Cache object properties in loops: `const value = obj.prop; for (...) { use value }`.
  - Cache function results in module-level Map when appropriate.
  - Cache `localStorage`/`sessionStorage` reads (avoid repeated access).
  - Combine multiple `filter`/`map` operations into a single loop.
  - Check array length before expensive comparisons.
  - Return early from functions to avoid unnecessary computation.
  - Hoist RegExp creation outside loops.
  - Use loop for min/max instead of `sort()`.
  - Use `Set`/`Map` for O(1) lookups instead of array `includes()`.
  - Use `toSorted()` for immutable array sorting (ES2023).

- **Advanced Patterns (LOW):**
  - Store event handlers in refs when they need to be stable across renders.
  - Use `useLatest` hook pattern for stable callback refs.

---

## React/Next.js Conventions
- **Component Declaration Order:**
  1. Imports
  2. Component declaration
  3. Styled components (if any)
  4. TypeScript types and interfaces

- **Component Structure:**
  - Small, focused components following single responsibility.
  - Use hooks for state management; avoid unnecessary re-renders.
  - Follow the `use client` directive judiciously.
  - Extract static JSX outside components to prevent recreation on each render.

- **State Management & Fetching:**
  - Prefer React Server Components (RSC) for data-heavy operations.
  - Use `next-safe-action` for secure server actions.
  - Leverage Supabase for real-time data synchronization.
  - Use React.cache() for per-request deduplication in Server Components.
  - Use SWR for automatic request deduplication in Client Components.

- **Eliminating Waterfalls (CRITICAL):**
  - Move `await` into branches where actually used, not at the top level.
  - Use `Promise.all()` for independent async operations.
  - Use better-all pattern for operations with partial dependencies.
  - Start promises early, await late in API routes and Server Components.
  - Use Suspense boundaries to stream content and eliminate waterfalls.

- **Bundle Size Optimization (CRITICAL):**
  - Import directly from source files, avoid barrel imports (`index.ts` re-exports).
  - Use `next/dynamic` with `ssr: false` for heavy client-only components.
  - Load analytics/logging libraries after hydration, not during initial load.
  - Load feature modules conditionally only when the feature is activated.
  - Preload modules on hover/focus for perceived performance improvements.

- **Server-Side Performance (HIGH):**
  - Use `React.cache()` for per-request deduplication in Server Components.
  - Use LRU cache for cross-request caching when appropriate.
  - Minimize data passed to Client Components (serialization cost).
  - Restructure components to parallelize independent data fetches.
  - Use `after()` for non-blocking operations that don't affect response.

- **Client-Side Data Fetching (MEDIUM-HIGH):**
  - Use SWR for automatic request deduplication and caching.
  - Deduplicate global event listeners (use single instance, share handlers).

- **Re-render Optimization (MEDIUM):**
  - Don't subscribe to state only used in callbacks (defer reads).
  - Extract expensive work into memoized components using `React.memo()`.
  - Use primitive dependencies in `useEffect` and `useMemo` hooks.
  - Subscribe to derived booleans, not raw values that cause unnecessary re-renders.
  - Use functional `setState` for stable callbacks: `setCount(c => c + 1)`.
  - Pass function to `useState` for expensive initial values: `useState(() => expensive())`.
  - Use `startTransition` for non-urgent updates (UI interactions stay responsive).

- **Rendering Performance (MEDIUM):**
  - Animate div wrapper elements, not SVG elements directly.
  - Use `content-visibility: auto` for long lists to improve rendering performance.
  - Extract static JSX outside components to prevent recreation.
  - Reduce SVG coordinate precision when possible.
  - Use inline script for client-only data to prevent hydration flicker.
  - Use ternary operator (`condition ? <A /> : <B />`) instead of `&&` for conditionals.
  - Use Activity component pattern for show/hide animations.

- **Performance Optimization:**
  - Lazy load non-critical components with `next/dynamic`.
  - Use Suspense with fallbacks for client-side components.
  - Optimize image loading with `next/image`.
  - Prioritize Web Vitals (LCP, CLS, FID, INP).

---

## AI SDK Integration (Vercel AI SDK)
- Use **Vercel AI SDK UI** for chat interfaces.
- Use **Vercel AI SDK Core** for model interactions.
- Handle rate limits and fallback gracefully.
- Sanitize user inputs before sending to models.
- Store API keys securely using environment variables.

---

## DrizzleORM Best Practices
- Use DrizzleORM for database interactions with Supabase.
- Leverage migrations for schema evolution.
- Follow the repository pattern to encapsulate database logic.
- Optimize queries with proper indexing.
- Adhere to Supabase RLS policies.

---

## Supabase & GraphQL Guidelines
- Use Genql for type-safe GraphQL queries.
- Follow Supabase best practices for authentication and authorization.
- Implement efficient data fetching by requesting only required fields.

---

## Naming Conventions
- **Booleans:** Prefix with `does`, `has`, `is`, `should` (e.g., `isValid`, `hasError`).
- **Files:** Use lowercase with dash separators (e.g., `project-detail.tsx`).
- **Extensions:** Follow the convention:
  - `.config.ts` for configurations
  - `.test.ts` for tests
  - `.context.tsx` for context files
  - `.type.ts` for types
  - `.hook.ts` for hooks

---

## Styling with Tailwind CSS
- Follow utility-first principles.
- Use CVA (Class Variance Authority) for managing component variants.
- Maintain a mobile-first responsive approach.

---

## Testing Guidelines
- **Unit Tests:** Use Jest for utility functions and hooks.
- **Integration Tests:** Validate component interactions.
- **End-to-End Tests:** Use Cypress for key user flows.
- Ensure code coverage meets project standards.

---

## Accessibility Guidelines
- Ensure all interactive elements are keyboard accessible.
- Use ARIA roles and attributes for screen readers.
- Maintain WCAG compliance for color contrast and readability.

---

## Documentation Standards
- Provide clear and concise comments for complex logic.
- Use JSDoc comments to improve IDE intellisense.
- Maintain up-to-date README files with setup instructions.
- Document Supabase schemas and edge functions where applicable.

---

## Key Conventions
1. Rely on Next.js App Router for routing and state changes.
2. Prioritize Web Vitals (LCP, CLS, FID) for performance.
3. Use a monorepo structure with shared code in `packages/` and app-specific code in `apps/`.
4. Use Taskfile for automation of development and deployment workflows.
5. Adhere to the defined database schema with enum tables for predefined values.

---

## Security Practices
- Store sensitive data in environment variables.
- Validate all incoming API requests for security compliance.
- Implement Role-Based Access Control (RBAC) using Supabase policies.
- Set security headers (CSP, HSTS, etc.) using Next.js config
- Implement rate limiting for API routes
- Use prepared statements for database queries
- Enable audit logging for sensitive operations
- Implement session management best practices
- Regular security dependency updates

---

## Performance Optimization (Summary)
- **Critical Priority:**
  - Eliminate async waterfalls using `Promise.all()` and Suspense boundaries.
  - Optimize bundle size: avoid barrel imports, use dynamic imports, defer third-party code.
  
- **High Priority:**
  - Use `React.cache()` for server-side request deduplication.
  - Parallelize independent data fetches.
  - Minimize serialization by reducing data passed to Client Components.

- **Medium Priority:**
  - Optimize re-renders with `React.memo()`, `useMemo`, and `startTransition`.
  - Use SWR for client-side request deduplication.
  - Improve rendering performance with `content-visibility` and optimized conditionals.

- **General:**
  - Minimize client-side dependencies.
  - Use streaming and Suspense features in Next.js.
  - Leverage Incremental Static Regeneration (ISR) where applicable.
  - Optimize bundle size using code splitting.
  - Prioritize Web Vitals (LCP, CLS, FID, INP) in all optimizations.

---

Refer to the official documentation for best practices in:
- **Next.js** (Data Fetching, Routing, Rendering)
- **Vercel AI SDK** (AI Integration)
- **Supabase** (Database and Authentication)
- **TailwindCSS** (Styling)

---

## Performance Optimization Reference (Vercel Best Practices)

These guidelines are based on Vercel Engineering's React and Next.js performance optimization patterns. When writing or reviewing code, prioritize rules by impact:

1. **CRITICAL**: Eliminating Waterfalls, Bundle Size Optimization
2. **HIGH**: Server-Side Performance
3. **MEDIUM-HIGH**: Client-Side Data Fetching
4. **MEDIUM**: Re-render Optimization, Rendering Performance
5. **LOW-MEDIUM**: JavaScript Performance
6. **LOW**: Advanced Patterns

For detailed explanations and code examples, refer to the Vercel React Best Practices guide or install the agent skills globally: `npx add-skill vercel-labs/agent-skills`
